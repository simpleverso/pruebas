<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Updated Title -->
    <title>Text, JSON & Base64 Tools</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f7f6;
            color: #333;
            margin: 0;
            padding: 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 700px;
        }
        h1 {
            color: #1a1a1a;
            text-align: center;
            margin-bottom: 1.5rem;
        }
        p {
            text-align: center;
            color: #555;
            margin-bottom: 2rem;
        }
        .form-group {
            margin-bottom: 1rem;
        }
        .label-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        .label-group h2, .label-group label {
            margin-bottom: 0;
        }
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }
        textarea, input[type="text"], select {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #ccc;
            font-size: 1rem;
            box-sizing: border-box; 
        }
        textarea {
            min-height: 150px;
            resize: vertical;
        }

        /* --- New Base64 Tool Styles --- */
        .tool-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background-color: #f9f9f9;
            border-radius: 8px;
        }
        .tool-selector label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-weight: 500;
        }
        .tool-selector input[type="radio"] {
            width: auto;
        }
        #imagePreview {
            display: none; /* Hidden by default */
            margin-top: 1rem;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 0.5rem;
            background-color: #fdfdfd;
        }
        #imagePreview img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
            border-radius: 4px;
        }
        /* --- End New Base64 Styles --- */


        /* Epoch section styles */
        .epoch-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .epoch-input-field {
            flex-grow: 1; /* Input takes available space */
            width: auto; /* Override default 100% */
        }
        .epoch-button-group {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0; /* Prevent buttons from shrinking */
        }
        .epoch-specific-button {
            width: auto; /* Override default 100% width from 'button' rule */
            padding: 12px 15px; /* Adjust padding to match input height */
            font-size: 0.9rem; /* Slightly smaller text to fit */
        }

        /* Drag and Drop & File Input Styles */
        .drop-zone {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
            color: #aaa;
            cursor: pointer;
            transition: border-color 0.3s, background-color 0.3s;
            margin-bottom: 1rem;
        }
        /* Will be toggled by JS */
        .drop-zone.hidden {
            display: none;
        }

        .drop-zone--over {
            border-color: #007bff;
            background-color: #f0f8ff;
        }
        .drop-zone__input {
            display: none;
        }
        .drop-zone__prompt {
            font-weight: 500;
        }
        .options {
            display: flex;
            align-items: center;
            margin-bottom: 1.5rem;
            gap: 10px; /* space between checkbox and label */
        }
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }
        .button-group {
            display: grid;
            /* Updated to 3 columns for better layout */
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }
        button {
            display: block;
            width: 100%;
            padding: 15px;
            border: none;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .primary-button {
             background: linear-gradient(45deg, #007bff, #0056b3);
        }
         .secondary-button {
            background: linear-gradient(45deg, #6c757d, #5a6268);
        }
        .tertiary-button {
            background: linear-gradient(45deg, #28a745, #218838);
        }
        .quaternary-button {
            background: linear-gradient(45deg, #fd7e14, #d35400); /* Orange gradient */
        }
        .quinary-button {
            background: linear-gradient(45deg, #6f42c1, #4a148c); /* Purple gradient */
        }
        .senary-button {
            background: linear-gradient(45deg, #20c997, #00796b); /* Teal gradient */
        }
        .septenary-button {
            background: linear-gradient(45deg, #dc3545, #b02a37); /* Red gradient */
        }
        /* New button style for Base64 */
        .octonary-button {
            background: linear-gradient(45deg, #d946ef, #a21caf); /* Fuchsia gradient */
        }
        /* New button style for AWS Request IDs */
        .nonary-button {
            background: linear-gradient(45deg, #0dcaf0, #08a5c7); /* Cyan gradient */
        }

        .epoch-button-gmt {
            background: linear-gradient(45deg, #17a2b8, #117a8b); /* Info/Cyan gradient */
        }
        .epoch-button-utc {
            background: linear-gradient(45deg, #ffc107, #d39e00); /* Warning/Yellow gradient */
        }
        .utility-button {
            padding: 5px 12px;
            font-size: 0.9rem;
            font-weight: 600;
            background: #e9ecef;
            color: #333;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .utility-button:hover {
            background-color: #d8dde1;
            transform: none;
            box-shadow: none;
        }
        .validation-message {
            text-align: center;
            margin: 1rem 0 0 0;
            font-weight: bold;
            padding: 10px;
            border-radius: 5px;
            display: none; /* Hidden by default */
        }
        .validation-message.valid {
            color: #155724;
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            display: block;
        }
        .validation-message.invalid {
            color: #721c24;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            display: block;
        }
        #output {
            margin-top: 1.5rem;
        }
        pre {
            background-color: #e9ecef;
            padding: 1rem;
            border-radius: 8px;
            white-space: pre-wrap; 
            word-wrap: break-word; 
            min-height: 150px;
            border: 1px solid #ddd;
            font-size: 1rem;
        }
        .result-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .download-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-left: auto; /* Pushes download to the right */
        }
        #xmlOptions {
            display: none; /* Hidden by default */
            margin-top: 1rem;
            padding: 1rem;
            border: 1px solid #eee;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        #xmlOptions.visible {
            display: block;
        }

    </style>
</head>
<body>

    <div class="container">
        <h1>Text, JSON & Base64 Tools</h1>
        <p>A versatile tool to format text, validate JSON, convert Epoch time, and encode/decode Base64.</p>
        
        <div class="form-group">
            <label for="delimiter">Delimiter (for new line insertion):</label>
            <input type="text" id="delimiter" value="," placeholder="e.g., , or ; or word">
        </div>

        <!-- Epoch Input Section -->
        <div class="form-group">
            <label for="epochInput">Epoch Timestamp (seconds or ms):</label>
            <div class="epoch-container">
                <input type="text" id="epochInput" class="epoch-input-field" placeholder="e.g., 1678886400 or 1678886400000">
                <div class="epoch-button-group">
                    <button onclick="convertEpochToGmtMinus6()" class="epoch-button-gmt epoch-specific-button">GMT-6</button>
                    <button onclick="convertEpochToUtc()" class="epoch-button-utc epoch-specific-button">UTC</button>
                </div>
            </div>
        </div>

        <!-- New Base64 Tool Selector -->
        <div class="form-group">
            <label>Base64 Tools:</label>
            <div class="tool-selector">
                <label>
                    <input type="radio" name="base64tool" value="textEncode" onchange="updateToolMode()"> Text Encode
                </label>
                <label>
                    <input type="radio" name="base64tool" value="textDecode" onchange="updateToolMode()"> Text Decode
                </label>
                <label>
                    <input type="radio" name="base64tool" value="imgEncode" onchange="updateToolMode()"> Image Encode
                </label>
                <label>
                    <input type="radio" name="base64tool" value="imgDecode" onchange="updateToolMode()"> Image Decode
                </label>
            </div>
        </div>

        <div class="form-group">
            <div class="label-group">
                <!-- This label will be updated by JS -->
                <label for="inputText" id="inputLabel">Input Text (for Text/JSON tools):</label>
                <button onclick="clearInput()" class="utility-button">Clear</button>
            </div>
             <!-- File Drop Zone - now accepts images -->
            <div id="dropZone" class="drop-zone">
                <span class="drop-zone__prompt" id="dropZonePrompt">Drag & drop a file here or click to select a file (.txt, .csv, .json)</span>
                <input type="file" id="fileInput" class="drop-zone__input" accept=".txt,.csv,.json,.png,.jpg,.jpeg,.gif,.webp">
            </div>
            <!-- Textarea will be hidden/shown by JS -->
            <textarea id="inputText" placeholder="Your file content, pasted text, or Base64 string will appear here..."></textarea>
            
            <!-- New Image Preview Area -->
            <div id="imagePreview">
                <img id="previewImageTag" src="" alt="Image Preview">
            </div>
        </div>

        <div class="options">
             <input type="checkbox" id="removeDelimiterCheckbox">
             <label for="removeDelimiterCheckbox">Remove the delimiter from the result</label>
        </div>
        
        <div class="button-group">
            <!-- New Base64 Button -->
            <button onclick="runBase64Tool()" class="octonary-button">Run Base64 Tool</button>
            <!-- Existing Buttons -->
            <button onclick="addNewLines()" class="primary-button">Convert Text</button>
            <button onclick="validateJson()" class="secondary-button">Validate JSON</button>
            <button onclick="formatJson()" class="tertiary-button">Format JSON</button>
            <button onclick="anonymizeAwsArns()" class="quaternary-button">Anonymize account ARNs</button>
            <button onclick="anonymizeAwsBuckets()" class="quinary-button">Anonymize Buckets ARNs</button>
            <button onclick="anonymizeAwsRoles()" class="senary-button">Anonymize Role ARNs</button>
            <button onclick="extractAwsResources()" class="septenary-button">Extract AWS Infra, CLI & IDs</button>
            <!-- New AWS Request ID Button -->
            <!-- <button onclick="extractAwsRequestIds()" class="nonary-button">Extract AWS Request IDs</button> --> <!-- This button is now merged -->
        </div>
        
        <p id="jsonValidationResult" class="validation-message"></p>
        
        <div id="output">
             <div class="label-group">
                <h2>Result:</h2>
                <div class="result-controls">
                     <button onclick="copyResult(this)" class="utility-button">Copy</button>
                     <div class="download-controls">
                        <select id="downloadFormat" onchange="toggleXmlOptions()">
                            <option value="txt">.txt</option>
                            <option value="csv">.csv</option>
                            <option value="json">.json</option>
                            <option value="xml">.xml</option>
                        </select>
                        <button onclick="downloadResult()" class="utility-button">Download</button>
                     </div>
                </div>
            </div>
             <div id="xmlOptions">
                <label for="xmlRoot">XML Root Tag:</label>
                <input type="text" id="xmlRoot" placeholder="e.g., data">
                <label for="xmlChild">XML Child Tag (for each line):</label>
                <input type="text" id="xmlChild" placeholder="e.g., item">
            </div>
            <pre id="outputText">Your formatted text will appear here.</pre>
        </div>
    </div>

    <script>
        // --- Global Element References ---
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const inputTextarea = document.getElementById('inputText');
        const outputTextarea = document.getElementById('outputText');
        const inputLabel = document.getElementById('inputLabel');
        const dropZonePrompt = document.getElementById('dropZonePrompt');
        const imagePreview = document.getElementById('imagePreview');
        const previewImageTag = document.getElementById('previewImageTag');
        const jsonValidationResult = document.getElementById('jsonValidationResult');
        
        // --- Page Load Initializer ---
        document.addEventListener('DOMContentLoaded', () => {
            // Set initial state
            updateToolMode();
        });


        // --- Drag and Drop & File Input Logic ---
        dropZone.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                handleFile(e.target.files[0]);
            }
        });

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => dropZone.classList.add('drop-zone--over'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => dropZone.classList.remove('drop-zone--over'), false);
        });

        dropZone.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const file = dt.files[0];
            handleFile(file);
        }, false);

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleFile(file) {
            const reader = new FileReader();
            const selectedTool = document.querySelector('input[name="base64tool"]:checked')?.value;

            if (selectedTool === 'imgEncode' && file.type.startsWith('image/')) {
                reader.onload = (e) => {
                    // Show image in preview
                    previewImageTag.src = e.target.result;
                    imagePreview.style.display = 'block';
                    // Put the Base64 string in the output
                    outputTextarea.textContent = e.target.result;
                    jsonValidationResult.style.display = 'none';
                };
                reader.readAsDataURL(file); // Reads as Base64 Data URL
            } else {
                // Default behavior: read as text
                reader.onload = (e) => {
                    inputTextarea.value = e.target.result;
                };
                reader.readAsText(file);
            }
        }

        // --- New Base64 Tool Logic ---
        function getSelectedTool() {
            const selected = document.querySelector('input[name="base64tool"]:checked');
            return selected ? selected.value : null;
        }

        function updateToolMode() {
            const selectedTool = getSelectedTool();
            
            // Default state
            inputTextarea.style.display = 'block';
            dropZone.classList.add('hidden');
            imagePreview.style.display = 'none';
            inputLabel.textContent = 'Input Text (for Text/JSON tools):';
            dropZonePrompt.textContent = 'Drag & drop a file here or click to select a file (.txt, .csv, .json)';
            fileInput.accept = '.txt,.csv,.json';

            switch (selectedTool) {
                case 'textEncode':
                    inputLabel.textContent = 'Text to Encode:';
                    break;
                case 'textDecode':
                    inputLabel.textContent = 'Base64 to Decode:';
                    break;
                case 'imgEncode':
                    inputTextarea.style.display = 'none';
                    dropZone.classList.remove('hidden');
                    inputLabel.textContent = 'Image to Encode:';
                    dropZonePrompt.textContent = 'Drag & drop an image or click to select (.png, .jpg, .gif, .webp)';
                    fileInput.accept = '.png,.jpg,.jpeg,.gif,.webp';
                    break;
                case 'imgDecode':
                    inputLabel.textContent = 'Base64 to Decode:';
                    imagePreview.style.display = 'block';
                    break;
            }
        }

        function runBase64Tool() {
            const selectedTool = getSelectedTool();
            const input = inputTextarea.value;
            jsonValidationResult.style.display = 'none';
            
            if (!selectedTool) {
                outputTextarea.textContent = 'Error: Please select a Base64 tool first.';
                return;
            }

            try {
                switch (selectedTool) {
                    case 'textEncode':
                        if (!input) {
                            outputTextarea.textContent = 'Error: No text provided to encode.';
                            return;
                        }
                        // Use btoa() to encode
                        // Handle Unicode characters correctly
                        const utf8Bytes = new TextEncoder().encode(input);
                        const base64String = btoa(String.fromCharCode.apply(null, utf8Bytes));
                        outputTextarea.textContent = base64String;
                        break;
                        
                    case 'textDecode':
                        if (!input) {
                            outputTextarea.textContent = 'Error: No Base64 string provided to decode.';
                            return;
                        }
                        // Use atob() to decode
                        const decodedBytes = atob(input).split('').map(c => c.charCodeAt(0));
                        const decodedText = new TextDecoder().decode(new Uint8Array(decodedBytes));
                        outputTextarea.textContent = decodedText;
                        break;

                    case 'imgEncode':
                        // This is handled by handleFile()
                        // This button click is a bit redundant, but we'll check
                        if (previewImageTag.src && outputTextarea.textContent.startsWith('data:image')) {
                             jsonValidationResult.textContent = 'Success: Image encoded. Base64 string is in the result box.';
                             jsonValidationResult.className = 'validation-message valid';
                        } else {
                            outputTextarea.textContent = 'Error: Please drop or select an image file using the area above.';
                        }
                        break;

                    case 'imgDecode':
                        if (!input) {
                            outputTextarea.textContent = 'Error: No Base64 string provided to decode.';
                            return;
                        }
                        // Check if it's a valid Data URL
                        if (input.startsWith('data:image')) {
                            previewImageTag.src = input;
                            imagePreview.style.display = 'block';
                            outputTextarea.textContent = 'Preview updated. You can copy the Base64 string from the input.';
                        } else {
                            outputTextarea.textContent = 'Error: Invalid Base64 string. Expected format: "data:image/png;base64,..."';
                        }
                        break;
                }
            } catch (error) {
                outputTextarea.textContent = 'Error: Failed to process. ' + error.message;
                if (selectedTool === 'textDecode') {
                     outputTextarea.textContent = 'Error: Invalid Base64 string. ' + error.message;
                }
            }
        }


        // --- Epoch Conversion Logic ---
        function getEpochDate() {
            const epochInput = document.getElementById('epochInput').value.trim();
            // Clear any previous JSON validation messages
            jsonValidationResult.style.display = 'none';

            if (!epochInput) {
                outputTextarea.textContent = "Error: Please enter an Epoch timestamp.";
                return null;
            }

            let timestamp = Number(epochInput);

            if (isNaN(timestamp)) {
                outputTextarea.textContent = "Error: Invalid timestamp. Please enter numbers only.";
                return null;
            }

            if (timestamp < 3000000000) {
                timestamp *= 1000; // Convert seconds to milliseconds
            }

            return new Date(timestamp);
        }

        function convertEpochToGmtMinus6() {
            const date = getEpochDate();
            if (!date) return; 

            const options = {
                timeZone: 'Etc/GMT+6', 
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false,
                timeZoneName: 'short'
            };

            try {
                const formattedDate = new Intl.DateTimeFormat('en-US', options).format(date);
                outputTextarea.textContent = `GMT-6: ${formattedDate}`;
            } catch (e) {
                outputTextarea.textContent = `Error formatting date: ${e.message}`;
            }
        }

        function convertEpochToUtc() {
            const date = getEpochDate();
            if (!date) return; 
            outputTextarea.textContent = `UTC: ${date.toUTCString()}`;
        }


        // --- Core Tool Logic ---
        function addNewLines() {
            const delimiter = document.getElementById('delimiter').value;
            const inputText = inputTextarea.value;
            const shouldRemoveDelimiter = document.getElementById('removeDelimiterCheckbox').checked;
            
            jsonValidationResult.style.display = 'none';

            if (!delimiter) {
                outputTextarea.textContent = "Error: Please enter a delimiter to convert text.";
                return;
            }

            const escapedDelimiter = delimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(escapedDelimiter, 'g');
            const replacement = shouldRemoveDelimiter ? '\n' : delimiter + '\n';
            const formattedText = inputText.replace(regex, replacement);
            outputTextarea.textContent = formattedText;
        }
        
        function validateJson() {
            const inputText = inputTextarea.value;
            outputTextarea.textContent = "Your formatted text will appear here.";
            
            if (!inputText.trim()) {
                jsonValidationResult.textContent = 'Input is empty. Cannot validate.';
                jsonValidationResult.className = 'validation-message invalid';
                return;
            }

            try {
                JSON.parse(inputText);
                jsonValidationResult.textContent = 'Success: Valid JSON structure!';
                jsonValidationResult.className = 'validation-message valid';
            } catch (error) {
                jsonValidationResult.textContent = 'Error: Invalid JSON. ' + error.message;
                jsonValidationResult.className = 'validation-message invalid';
            }
        }
        
        function formatJson() {
            const inputText = inputTextarea.value;
            outputTextarea.textContent = "Your formatted text will appear here.";

            if (!inputText.trim()) {
                jsonValidationResult.textContent = 'Input is empty. Cannot format.';
                jsonValidationResult.className = 'validation-message invalid';
                return;
            }

            try {
                const jsonObject = JSON.parse(inputText);
                const formattedJson = JSON.stringify(jsonObject, null, 2); 
                outputTextarea.textContent = formattedJson;
                jsonValidationResult.textContent = 'Success: JSON formatted!';
                jsonValidationResult.className = 'validation-message valid';
            } catch (error) {
                jsonValidationResult.textContent = 'Error: Invalid JSON. Cannot format. ' + error.message;
                jsonValidationResult.className = 'validation-message invalid';
            }
        }

        // --- ARN Anonymizer Function ---
        function anonymizeAwsArns() {
            const inputText = inputTextarea.value;
            jsonValidationResult.style.display = 'none';

            if (!inputText.trim()) {
                outputTextarea.textContent = "Input is empty. Cannot anonymize.";
                return;
            }

            const arnRegex = /(arn:[^:]+:[^:]+:[^:]+:)(\d{12})(:.*)/g;
            const accountMap = new Map();
            let accountCounter = 1;

            const anonymizedText = inputText.replace(arnRegex, (match, prefix, accountId, suffix) => {
                let newId;
                if (accountMap.has(accountId)) {
                    newId = accountMap.get(accountId);
                } else {
                    newId = '09999999' + accountCounter;
                    accountMap.set(accountId, newId);
                    accountCounter++;
                }
                return prefix + newId + suffix;
            });

            outputTextarea.textContent = anonymizedText;
        }
        
        // --- Bucket Anonymizer Function ---
        function anonymizeAwsBuckets() {
            const inputText = inputTextarea.value;
            jsonValidationResult.style.display = 'none';
        
            if (!inputText.trim()) {
                outputTextarea.textContent = "Input is empty. Cannot anonymize.";
                return;
            }
        
            const bucketArnRegex = /(arn:[^:]+:s3:::)([^/]+)(.*)/g;
            const bucketMap = new Map();
            let bucketCounter = 1;
        
            const anonymizedText = inputText.replace(bucketArnRegex, (match, prefix, bucketName, suffix) => {
                let newId;
                if (bucketMap.has(bucketName)) {
                    newId = bucketMap.get(bucketName);
                } else {
                    newId = 'bucket999' + bucketCounter;
                    bucketMap.set(bucketName, newId);
                    bucketCounter++;
                }
                return prefix + newId + suffix;
            });
        
            outputTextarea.textContent = anonymizedText;
        }

        // --- Role Anonymizer Function ---
        function anonymizeAwsRoles() {
            const inputText = inputTextarea.value;
            jsonValidationResult.style.display = 'none';
        
            if (!inputText.trim()) {
                outputTextarea.textContent = "Input is empty. Cannot anonymize.";
                return;
            }
        
            const roleArnRegex = /(arn:[^:]+:iam:[^:]*:[^:]*:role\/)([\w\+\=\,\.\@\-\/]+)/g;
            const roleMap = new Map();
            let roleCounter = 1;
        
            const anonymizedText = inputText.replace(roleArnRegex, (match, prefix, roleName) => {
                let newId;
                if (roleMap.has(roleName)) {
                    newId = roleMap.get(roleName);
                } else {
                    newId = 'role999' + roleCounter;
                    roleMap.set(roleName, newId);
                    roleCounter++;
                }
                return prefix + newId;
            });
        
            outputTextarea.textContent = anonymizedText;
        }

        // --- AWS Resource Extractor Function ---
        function extractAwsResources() {
            const inputText = inputTextarea.value;
            jsonValidationResult.style.display = 'none';

            if (!inputText.trim()) {
                outputTextarea.textContent = "Input is empty. Cannot extract resources.";
                return;
            }

            const vpcRegex = /(vpc-[0-9a-fA-F]{8,17})/g;
            const subnetRegex = /(subnet-[0-9a-fA-F]{8,17})/g;
            const sgRegex = /(sg-[0-9a-fA-F]{8,17})/g;
            const roleRegex = /(arn:[^:]+:iam:[^:]*:[^:]*:role\/[\w\+\=\,\.\@\-\/]+)/g;
            // Regex for request IDs
            const requestIdRegex = /x-amz-request-id:?\s*([0-9A-F]{16,})/gi;
            const id2Regex = /x-amz-id-2:?\s*([A-Za-z0-9/+=]{40,})/gi;
            // New Regex for UUID-style Request IDs (e.g., from API Gateway, Lambda)
            // The prefix group (?:...) is now optional with the final '?'
            const uuidRequestIdRegex = /(?:x-amzn-RequestId:?\s*|[Rr]equestId:?\s*)?([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})/gi;

            const vpcs = [...new Set(inputText.match(vpcRegex) || [])];
            const subnets = [...new Set(inputText.match(subnetRegex) || [])];
            const sgs = [...new Set(inputText.match(sgRegex) || [])];
            const roles = [...new Set(inputText.match(roleRegex) || [])];
            
            // Find request IDs
            const requestIds = [...inputText.matchAll(requestIdRegex)];
            const id2s = [...inputText.matchAll(id2Regex)];
            const uuidRequestIds = [...inputText.matchAll(uuidRequestIdRegex)]; // Added this line

            const allRequestIds = new Set();
            requestIds.forEach(match => allRequestIds.add(match[1])); // S3 style
            id2s.forEach(match => allRequestIds.add(match[1])); // S3 style
            // Capture group is now 1 because the (optional) prefix group is non-capturing (?:...)
            uuidRequestIds.forEach(match => allRequestIds.add(match[1])); // UUID style (now 1st capture group)

            let output = "";
            const cliOutput = [];

            if (vpcs.length > 0) {
                output += `VPCs (${vpcs.length}):\n${vpcs.join('\n')}\n\n`;
                cliOutput.push(`aws ec2 describe-vpcs --vpc-ids ${vpcs.join(' ')}`);
            }
            if (subnets.length > 0) {
                output += `Subnets (${subnets.length}):\n${subnets.join('\n')}\n\n`;
                cliOutput.push(`aws ec2 describe-subnets --subnet-ids ${subnets.join(' ')}`);
            }
            if (sgs.length > 0) {
                output += `Security Groups (${sgs.length}):\n${sgs.join('\n')}\n\n`;
                cliOutput.push(`aws ec2 describe-security-groups --group-ids ${sgs.join(' ')}`);
            }
            if (roles.length > 0) {
                output += `Execution Roles (IAM) (${roles.length}):\n${roles.join('\n')}\n\n`;
                
                const roleCommands = roles.map(role => {
                    const roleNameMatch = role.match(/role\/(.+)/);
                    if (roleNameMatch && roleNameMatch[1]) {
                        return `aws iam get-role --role-name ${roleNameMatch[1]}`;
                    }
                    return null;
                }).filter(Boolean); 

                if (roleCommands.length > 0) {
                    cliOutput.push(...roleCommands);
                }
            }

            // Add request IDs to output
            if (allRequestIds.size > 0) {
                output += `AWS Request IDs (${allRequestIds.size}):\n${Array.from(allRequestIds).join('\n')}\n\n`;
            }

            if (output === "") {
                outputTextarea.textContent = "No AWS VPCs, Subnets, Security Groups, Execution Roles, or Request IDs found.";
            } else {
                if (cliOutput.length > 0) {
                    output += "--- AWS CLI Describe Commands ---\n";
                    output += cliOutput.join('\n');
                }
                outputTextarea.textContent = output.trim();
            }
        }

        // --- AWS Request ID Extractor Function ---
        /* This function is now merged into extractAwsResources()
        function extractAwsRequestIds() {
            const inputText = inputTextarea.value;
            jsonValidationResult.style.display = 'none';

            if (!inputText.trim()) {
                outputTextarea.textContent = "Input is empty. Cannot extract IDs.";
                return;
            }

            // Regex for x-amz-request-id: typically 16+ uppercase hex chars
            const requestIdRegex = /x-amz-request-id:?\s*([0-9A-F]{16,})/gi;
            // Regex for x-amz-id-2: typically 40+ Base64 chars
            const id2Regex = /x-amz-id-2:?\s*([A-Za-z0-9/+=]{40,})/gi;

            const requestIds = [...inputText.matchAll(requestIdRegex)];
            const id2s = [...inputText.matchAll(id2Regex)];

            const allIds = new Set();
            requestIds.forEach(match => allIds.add(match[1])); // Add the captured group (the ID)
            id2s.forEach(match => allIds.add(match[1])); // Add the captured group (the ID)

            if (allIds.size === 0) {
                outputTextarea.textContent = "No 'x-amz-request-id' or 'x-amz-id-2' values found meeting criteria (16+ hex for request-id, 40+ base64 for id-2).";
            } else {
                outputTextarea.textContent = Array.from(allIds).join('\n');
            }
        }
        */

        // --- Utility Functions ---

        function clearInput() {
            inputTextarea.value = '';
            document.getElementById('epochInput').value = ''; 
            outputTextarea.textContent = 'Your formatted text will appear here.';
            jsonValidationResult.style.display = 'none';
            fileInput.value = ''; // Clear file input selection
            
            // Clear Base64 radio buttons
            const radios = document.getElementsByName('base64tool');
            radios.forEach(radio => radio.checked = false);
            
            // Clear image preview
            previewImageTag.src = '';
            imagePreview.style.display = 'none';

            // Reset tool mode to default
            updateToolMode();
        }

        function copyResult(copyButton) {
            const outputText = outputTextarea.textContent;

            if (outputText === 'Your formatted text will appear here.' || !outputText.trim()) {
                copyButton.textContent = 'Nothing to copy!';
                setTimeout(() => {
                    copyButton.textContent = 'Copy';
                }, 2000);
                return;
            }

            const textarea = document.createElement('textarea');
            textarea.value = outputText;
            textarea.style.position = 'fixed'; 
            textarea.style.opacity = 0;
            document.body.appendChild(textarea);
            textarea.select();
            
            try {
                document.execCommand('copy');
                copyButton.textContent = 'Copied!';
            } catch (err) {
                copyButton.textContent = 'Failed!';
                console.error('Failed to copy text: ', err);
            }
            
            document.body.removeChild(textarea);

            setTimeout(() => {
                copyButton.textContent = 'Copy';
            }, 2000);
        }

        function toggleXmlOptions() {
            const format = document.getElementById('downloadFormat').value;
            const xmlOptions = document.getElementById('xmlOptions');
            if (format === 'xml') {
                xmlOptions.classList.add('visible');
            } else {
                xmlOptions.classList.remove('visible');
            }
        }

        function downloadResult() {
            let content = outputTextarea.textContent;
            const format = document.getElementById('downloadFormat').value;
            let mimeType = 'text/plain';
            let filename = `result.${format}`;

            if (content === 'Your formatted text will appear here.' || !content.trim()) {
                const downloadBtn = event.target;
                const originalText = downloadBtn.textContent;
                downloadBtn.textContent = 'No content!';
                setTimeout(() => { downloadBtn.textContent = originalText; }, 2000);
                return;
            }

            switch(format) {
                case 'csv':
                    mimeType = 'text/csv';
                    break;
                case 'json':
                    mimeType = 'application/json';
                    break;
                case 'xml':
                    mimeType = 'application/xml';
                    const rootTag = document.getElementById('xmlRoot').value || 'root';
                    const childTag = document.getElementById('xmlChild').value || 'item';
                    const lines = content.trim().split('\n');
                    const xmlLines = lines.map(line => {
                        const escapedLine = line.replace(/&/g, '&amp;')
                                                .replace(/</g, '&lt;')
                                                .replace(/>/g, '&gt;')
                                                .replace(/"/g, '&quot;')
                                                .replace(/'/g, '&apos;');
                        return `  <${childTag}>${escapedLine}</${childTag}>`;
                    });
                    content = `<?xml version="1.0" encoding="UTF-8"?>\n<${rootTag}>\n${xmlLines.join('\n')}\n</${rootTag}>`;
                    break;
                case 'txt':
                default:
                    mimeType = 'text/plain';
                    break;
            }

            const blob = new Blob([content], { type: mimeType });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }
    </script>

</body>
</html>



