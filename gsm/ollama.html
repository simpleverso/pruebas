<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ollama Web Client</title>
    <!-- Load Tailwind CSS from CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class', // 'media' or 'class'
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        }
    </script>
    <style>
        /* Custom scrollbar for chat history */
        .chat-history::-webkit-scrollbar {
            width: 8px;
        }
        .chat-history::-webkit-scrollbar-track {
            background: #1f2937; /* bg-gray-800 */
            border-radius: 4px;
        }
        .chat-history::-webkit-scrollbar-thumb {
            background: #4b5563; /* bg-gray-600 */
            border-radius: 4px;
        }
        .chat-history::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* bg-gray-500 */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans antialiased">

    <!-- Changed max-w-4xl to max-w-7xl to accommodate two chats -->
    <div class="container max-w-7xl mx-auto p-4 sm:p-6 lg:p-8 flex flex-col gap-6">

        <header class="text-center">
            <h1 class="text-3xl sm:text-4xl font-bold text-cyan-400">Ollama Web Client</h1>
            <p class="text-lg text-gray-400 mt-2">Analyze text and chat with your local models.</p>
        </header>

        <!-- Configuration Section -->
        <section class="bg-gray-800 rounded-xl shadow-lg p-6">
            <h2 class="text-2xl font-bold text-cyan-400 mb-4">Configuration</h2>
            
            <!-- CORS Warning -->
            <div class="bg-yellow-900 border border-yellow-700 text-yellow-200 px-4 py-3 rounded-lg mb-4" role="alert">
                <strong class="font-bold">Important!</strong>
                <span class="block sm:inline">For this client to work, you must start your Ollama server with the `OLLAMA_ORIGINS=*` environment variable. (e.g., `OLLAMA_ORIGINS='*' ollama serve`)</span>
            </div>

            <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                <div class="sm:col-span-2">
                    <label for="ollama-endpoint" class="block text-sm font-medium text-gray-300 mb-2">Ollama API Endpoint</label>
                    <input type="text" id="ollama-endpoint" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3 text-gray-100 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition" value="http://localhost:11434">
                </div>
                <div>
                    <label for="model-select" class="block text-sm font-medium text-gray-300 mb-2">Model</label>
                    <select id="model-select" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3 text-gray-100 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition">
                        <option value="" disabled>Loading models...</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-1">Models installed in Ollama will appear here.</p>
                </div>
            </div>

            <!-- NEW: Test Connection Button -->
            <div class="mt-4 flex justify-start">
                <button id="test-connection-btn" class="px-5 py-2 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 transition shadow focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800">
                    Test Connection & Reload Models
                </button>
            </div>

            <!-- System Prompt -->
            <div class="mt-4">
                <label for="system-prompt" class="block text-sm font-medium text-gray-300 mb-2">Global System Prompt (Optional)</label>
                <textarea id="system-prompt" rows="3" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3 text-gray-100 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition" placeholder="e.g., You are a helpful assistant. Respond in JSON. (Applied to all chats)"></textarea>
            </div>
            
            <div id="connection-status" class="mt-4 text-sm"></div>
        </section>

        <!-- Tab Navigation -->
        <div class="mb-4 border-b border-gray-700">
            <nav class="-mb-px flex space-x-8" role="tablist" aria-label="Tabs">
                <button id="tab-chat" role="tab" aria-selected="true"
                    class="border-cyan-500 text-cyan-400 whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors focus:outline-none">
                    Chat
                </button>
                <button id="tab-analysis" role="tab" aria-selected="false"
                    class="border-transparent text-gray-400 hover:border-gray-500 hover:text-gray-300 whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors focus:outline-none">
                    Text Analysis
                </button>
            </nav>
        </div>

        <!-- Tab Content -->
        <div>
            <!-- Chat Panel (Default Visible) -->
            <div id="panel-chat" role="tabpanel" aria-labelledby="tab-chat">
                <section class="flex flex-col gap-6">
                    <!-- NEW: Global Chat Management -->
                    <div class="flex justify-between items-center">
                        <h2 class="text-3xl font-bold text-cyan-400">Multi-Chat</h2>
                        <button id="new-chat-btn" class="px-5 py-2 bg-green-600 text-white rounded-lg font-semibold hover:bg-green-700 transition shadow focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            New Chat
                        </button>
                    </div>
                    
                    <!-- NEW: 2-Column Chat Layout -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">

                        <!-- Panel A -->
                        <div id="chat-panel-a" class="bg-gray-800 rounded-xl shadow-lg p-6 flex flex-col gap-4">
                            <h3 class="text-xl font-semibold text-gray-300">Panel A</h3>
                            <!-- NEW: Per-Chat Model Select A -->
                            <div class="flex flex-col">
                                <label for="chat-model-select-a" class="text-sm font-medium text-gray-300 mb-1">Model</label>
                                <select id="chat-model-select-a" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-gray-100 text-sm focus:ring-2 focus:ring-cyan-500 focus:outline-none transition">
                                    <option>Loading models...</option>
                                </select>
                            </div>
                            <!-- Local System Prompt A -->
                            <div class="flex flex-col">
                                <label for="chat-system-prompt-a" class="text-sm font-medium text-gray-300 mb-1">Chat System Prompt (Overrides Global)</label>
                                <textarea id="chat-system-prompt-a" rows="2" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-gray-100 text-sm focus:ring-2 focus:ring-cyan-500 focus:outline-none transition" placeholder="e.g., You are a pirate."></textarea>
                            </div>
                            <!-- Session Control A -->
                            <div class="flex gap-2">
                                <label for="chat-select-a" class="flex-shrink-0 text-sm font-medium text-gray-300 py-2">Session:</label>
                                <select id="chat-select-a" class="flex-grow bg-gray-700 border border-gray-600 rounded-lg p-2 text-gray-100 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition text-sm">
                                    <option>Loading...</option>
                                </select>
                                <button id="delete-chat-btn-a" class="flex-shrink-0 px-3 py-2 bg-red-600 text-white rounded-lg font-semibold hover:bg-red-700 transition shadow focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-gray-800" title="Delete Selected Chat">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1zm2 4a1 1 0 100 2h2a1 1 0 100-2H9z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                            <!-- History A -->
                            <div id="chat-history-a" class="chat-history h-96 bg-gray-900 rounded-lg p-4 border border-gray-700 overflow-y-auto flex flex-col gap-4">
                                <!-- Messages for A -->
                            </div>
                            <!-- NEW: Image Preview A -->
                            <div id="chat-image-preview-a" class="hidden relative w-24 h-24 mb-2">
                                <img id="preview-img-a" src="" class="w-full h-full object-cover rounded-lg border border-gray-600">
                                <button id="remove-img-btn-a" class="absolute top-0 right-0 -mt-2 -mr-2 bg-red-600 text-white rounded-full p-0 w-6 h-6 flex items-center justify-center text-lg font-bold leading-none focus:outline-none">&times;</button>
                            </div>
                            <!-- Input A -->
                            <div class="flex gap-2">
                                <input id="chat-input-a" type="text" class="flex-grow bg-gray-700 border border-gray-600 rounded-lg p-3 text-gray-100 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition" placeholder="Type message for Panel A...">
                                <!-- NEW: Hidden file input -->
                                <input type="file" id="chat-file-input-a" class="hidden" accept="image/*">
                                <!-- NEW: Image attach button -->
                                <button id="chat-attach-btn-a" class="px-4 py-3 bg-gray-600 text-white rounded-lg font-semibold hover:bg-gray-700 transition shadow focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-800" title="Attach Image">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M8 4a3 3 0 00-3 3v4a3 3 0 106 0V7a1 1 0 112 0v4a5 5 0 11-10 0V7a5 5 0 0110 0v4a3 3 0 11-6 0V7a1 1 0 011-1z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                                <button id="chat-send-btn-a" class="px-6 py-3 bg-cyan-600 text-white rounded-lg font-semibold hover:bg-cyan-700 transition shadow focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-offset-2 focus:ring-offset-gray-800">Send</button>
                            </div>
                        </div>

                        <!-- Panel B -->
                        <div id="chat-panel-b" class="bg-gray-800 rounded-xl shadow-lg p-6 flex flex-col gap-4">
                            <h3 class="text-xl font-semibold text-gray-300">Panel B</h3>
                            <!-- NEW: Per-Chat Model Select B -->
                            <div class="flex flex-col">
                                <label for="chat-model-select-b" class="text-sm font-medium text-gray-300 mb-1">Model</label>
                                <select id="chat-model-select-b" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-gray-100 text-sm focus:ring-2 focus:ring-cyan-500 focus:outline-none transition">
                                    <option>Loading models...</option>
                                </select>
                            </div>
                            <!-- Local System Prompt B -->
                            <div class="flex flex-col">
                                <label for="chat-system-prompt-b" class="text-sm font-medium text-gray-300 mb-1">Chat System Prompt (Overrides Global)</label>
                                <textarea id="chat-system-prompt-b" rows="2" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-gray-100 text-sm focus:ring-2 focus:ring-cyan-500 focus:outline-none transition" placeholder="e.g., You are a helpful C++ expert."></textarea>
                            </div>
                            <!-- Session Control B -->
                            <div class="flex gap-2">
                                <label for="chat-select-b" class="flex-shrink-0 text-sm font-medium text-gray-300 py-2">Session:</label>
                                <select id="chat-select-b" class="flex-grow bg-gray-700 border border-gray-600 rounded-lg p-2 text-gray-100 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition text-sm">
                                    <option>Loading...</option>
                                </select>
                                <button id="delete-chat-btn-b" class="flex-shrink-0 px-3 py-2 bg-red-600 text-white rounded-lg font-semibold hover:bg-red-700 transition shadow focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-gray-800" title="Delete Selected Chat">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1zm2 4a1 1 0 100 2h2a1 1 0 100-2H9z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                            <!-- History B -->
                            <div id="chat-history-b" class="chat-history h-96 bg-gray-900 rounded-lg p-4 border border-gray-700 overflow-y-auto flex flex-col gap-4">
                                <!-- Messages for B -->
                            </div>
                            <!-- NEW: Image Preview B -->
                            <div id="chat-image-preview-b" class="hidden relative w-24 h-24 mb-2">
                                <img id="preview-img-b" src="" class="w-full h-full object-cover rounded-lg border border-gray-600">
                                <button id="remove-img-btn-b" class="absolute top-0 right-0 -mt-2 -mr-2 bg-red-600 text-white rounded-full p-0 w-6 h-6 flex items-center justify-center text-lg font-bold leading-none focus:outline-none">&times;</button>
                            </div>
                            <!-- Input B -->
                            <div class="flex gap-2">
                                <input id="chat-input-b" type="text" class="flex-grow bg-gray-700 border border-gray-600 rounded-lg p-3 text-gray-100 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition" placeholder="Type message for Panel B...">
                                <!-- NEW: Hidden file input -->
                                <input type="file" id="chat-file-input-b" class="hidden" accept="image/*">
                                <!-- NEW: Image attach button -->
                                <button id="chat-attach-btn-b" class="px-4 py-3 bg-gray-600 text-white rounded-lg font-semibold hover:bg-gray-700 transition shadow focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-800" title="Attach Image">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M8 4a3 3 0 00-3 3v4a3 3 0 106 0V7a1 1 0 112 0v4a5 5 0 11-10 0V7a5 5 0 0110 0v4a3 3 0 11-6 0V7a1 1 0 011-1z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                                <button id="chat-send-btn-b" class="px-6 py-3 bg-cyan-600 text-white rounded-lg font-semibold hover:bg-cyan-700 transition shadow focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-offset-2 focus:ring-offset-gray-800">Send</button>
                            </div>
                        </div>

                    </div>
                </section>
            </div>

            <!-- Analysis Panel (Default Hidden) -->
            <div id="panel-analysis" role="tabpanel" aria-labelledby="tab-analysis" class="hidden">
                <section class="bg-gray-800 rounded-xl shadow-lg p-6">
                    <h2 class="text-2xl font-bold text-cyan-400 mb-4">Text Analysis</h2>
                    <div class="flex flex-col gap-4">
                        <!-- Input Text -->
                        <div>
                            <div class="flex justify-between items-center mb-2">
                                <label for="analysis-input" class="block text-sm font-medium text-gray-300">Text to Analyze</label>
                                <button id="copy-input-btn" class="text-xs bg-gray-600 text-gray-200 px-3 py-1 rounded-md font-semibold hover:bg-gray-500 transition">Copy</button>
                            </div>
                            <textarea id="analysis-input" rows="8" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3 text-gray-100 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition" placeholder="Paste your text here..."></textarea>
                        </div>
        
                        <!-- Analyze Button -->
                        <button id="analyze-btn" class="w-full sm:w-auto self-center px-6 py-3 bg-cyan-600 text-white rounded-lg font-semibold hover:bg-cyan-700 transition shadow-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                            Analyze Text
                        </button>
        
                        <!-- Output Text -->
                        <div>
                            <div class="flex justify-between items-center mb-2">
                                <label for="analysis-output" class="block text-sm font-medium text-gray-300">Analysis Result</label>
                                <button id="copy-output-btn" class="text-xs bg-gray-600 text-gray-200 px-3 py-1 rounded-md font-semibold hover:bg-gray-500 transition">Copy</button>
                            </div>
                            <textarea id="analysis-output" rows="8" class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-gray-300 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition" placeholder="Analysis will appear here..." readonly></textarea>
                        </div>
                    </div>
                </section>
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Storage Keys ---
            const STORAGE_KEY_ENDPOINT = 'ollama_endpoint';
            const STORAGE_KEY_MODEL = 'ollama_model';
            const STORAGE_KEY_SYSTEM_PROMPT = 'ollama_system_prompt';
            const STORAGE_KEY_ANALYSIS_INPUT = 'ollama_analysis_input';
            const STORAGE_KEY_CHAT_SESSIONS = 'ollama_chat_sessions';
            const STORAGE_KEY_ACTIVE_CHAT_A = 'ollama_active_chat_a';
            const STORAGE_KEY_ACTIVE_CHAT_B = 'ollama_active_chat_b';

            // --- DOM Elements ---
            const ollamaEndpoint = document.getElementById('ollama-endpoint');
            const modelSelect = document.getElementById('model-select');
            const connectionStatus = document.getElementById('connection-status');
            const systemPrompt = document.getElementById('system-prompt');
            const testConnectionBtn = document.getElementById('test-connection-btn'); // <-- NEW

            // Analysis Elements
            const analysisInput = document.getElementById('analysis-input');
            const analysisOutput = document.getElementById('analysis-output');
            const analyzeBtn = document.getElementById('analyze-btn');
            const copyInputBtn = document.getElementById('copy-input-btn');
            const copyOutputBtn = document.getElementById('copy-output-btn');

            // --- Chat Elements (Panel A) ---
            const chatSelectA = document.getElementById('chat-select-a');
            const deleteChatBtnA = document.getElementById('delete-chat-btn-a');
            const chatHistoryA = document.getElementById('chat-history-a');
            const chatInputA = document.getElementById('chat-input-a');
            const chatSendBtnA = document.getElementById('chat-send-btn-a');
            const chatSystemPromptA = document.getElementById('chat-system-prompt-a');
            // NEW: Image Elements A
            const chatAttachBtnA = document.getElementById('chat-attach-btn-a');
            const chatFileInputA = document.getElementById('chat-file-input-a');
            const chatImagePreviewA = document.getElementById('chat-image-preview-a');
            const previewImgA = document.getElementById('preview-img-a');
            const removeImgBtnA = document.getElementById('remove-img-btn-a');
            const chatModelSelectA = document.getElementById('chat-model-select-a'); // <-- NEW


            // --- Chat Elements (Panel B) ---
            const chatSelectB = document.getElementById('chat-select-b');
            const deleteChatBtnB = document.getElementById('delete-chat-btn-b');
            const chatHistoryB = document.getElementById('chat-history-b');
            const chatInputB = document.getElementById('chat-input-b');
            const chatSendBtnB = document.getElementById('chat-send-btn-b');
            const chatSystemPromptB = document.getElementById('chat-system-prompt-b');
            // NEW: Image Elements B
            const chatAttachBtnB = document.getElementById('chat-attach-btn-b');
            const chatFileInputB = document.getElementById('chat-file-input-b');
            const chatImagePreviewB = document.getElementById('chat-image-preview-b');
            const previewImgB = document.getElementById('preview-img-b');
            const removeImgBtnB = document.getElementById('remove-img-btn-b');
            const chatModelSelectB = document.getElementById('chat-model-select-b'); // <-- NEW

            // --- Global Chat Elements ---
            const newChatBtn = document.getElementById('new-chat-btn');

            // Tab Elements
            const tabChat = document.getElementById('tab-chat');
            const tabAnalysis = document.getElementById('tab-analysis');
            const panelChat = document.getElementById('panel-chat');
            const panelAnalysis = document.getElementById('panel-analysis');

            // --- State ---
            let allChats = {}; // Object to store all chat sessions
            let activeChatIdA = null;
            let activeChatIdB = null;
            let savedModel = localStorage.getItem(STORAGE_KEY_MODEL);
            // NEW: Staged images state
            let stagedImageA = null; // Will store { dataUrl, base64 }
            let stagedImageB = null; // Will store { dataUrl, base64 }

            // --- Load Saved Values ---
            const savedEndpoint = localStorage.getItem(STORAGE_KEY_ENDPOINT);
            if (savedEndpoint) ollamaEndpoint.value = savedEndpoint;

            const savedSystemPrompt = localStorage.getItem(STORAGE_KEY_SYSTEM_PROMPT);
            if (savedSystemPrompt) systemPrompt.value = savedSystemPrompt;

            const savedAnalysisInput = localStorage.getItem(STORAGE_KEY_ANALYSIS_INPUT);
            if (savedAnalysisInput) analysisInput.value = savedAnalysisInput;

            // --- Helper Functions ---

            function copyToClipboard(text, buttonEl) {
                if (!text) return;
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = 0;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    const originalText = buttonEl.textContent;
                    buttonEl.textContent = 'Copied!';
                    setTimeout(() => { buttonEl.textContent = originalText; }, 2000);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    showMessage('Failed to copy text.', 'error');
                }
                document.body.removeChild(textarea);
            }

            function showMessage(message, type = 'error') {
                connectionStatus.textContent = message;
                connectionStatus.classList.remove(type === 'error' ? 'text-green-400' : 'text-red-400');
                connectionStatus.classList.add(type === 'error' ? 'text-red-400' : 'text-green-400');
            }

            /**
             * Adds a message bubble to a specific chat history UI.
             * @param {HTMLElement} historyElement - The chat history element (e.g., chatHistoryA).
             * @param {'user' | 'model'} role - Who sent the message.
             * @param {string} content - The text content of the message.
             * @param {string | null} dataUrl - The data URL of an image to display.
             * @returns {HTMLElement} - The p element created for the message.
             */
            function addMessageToChatUI(historyElement, role, content, dataUrl = null) {
                const messageWrapper = document.createElement('div');
                const messageBubble = document.createElement('div');
                const messageContent = document.createElement('p');
                
                messageWrapper.classList.add('flex');
                messageBubble.classList.add('p-3', 'rounded-lg', 'max-w-xs', 'sm:max-w-md');
                messageContent.classList.add('text-sm');

                if (role === 'user') {
                    messageWrapper.classList.add('justify-end');
                    messageBubble.classList.add('bg-gray-700', 'text-gray-100');
                } else {
                    messageWrapper.classList.add('justify-start');
                    messageBubble.classList.add('bg-cyan-800', 'text-cyan-100');
                }

                // NEW: Add image if it exists
                if (dataUrl) {
                    const img = document.createElement('img');
                    img.src = dataUrl;
                    img.classList.add('w-full', 'max-w-xs', 'rounded-lg', 'mb-2');
                    messageBubble.appendChild(img);
                }

                // Add text content if it exists, or if it's a model bubble (for streaming)
                if (content) {
                    messageContent.textContent = content;
                    messageBubble.appendChild(messageContent);
                } else if (role === 'model') {
                    messageContent.textContent = '...'; // For '...' typing bubble
                    messageBubble.appendChild(messageContent);
                }
                // If content is empty but dataUrl exists, the <p> is just not added. This is correct.

                messageWrapper.appendChild(messageBubble);
                historyElement.appendChild(messageWrapper);
                historyElement.scrollTop = historyElement.scrollHeight;

                return messageContent; // Return the p tag for streaming updates
            }


            // --- NEW: Image Handling Functions ---
            
            /**
             * Handles file selection from the input.
             * @param {'a' | 'b'} panelSuffix - The panel to handle the upload for.
             * @param {Event} event - The file input change event.
             */
            function handleImageUpload(panelSuffix, event) {
                const file = event.target.files[0];
                if (!file || !file.type.startsWith('image/')) {
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    const base64 = dataUrl.split(',')[1];
                    
                    if (panelSuffix === 'a') {
                        stagedImageA = { dataUrl, base64 };
                        previewImgA.src = dataUrl;
                        chatImagePreviewA.classList.remove('hidden');
                    } else {
                        stagedImageB = { dataUrl, base64 };
                        previewImgB.src = dataUrl;
                        chatImagePreviewB.classList.remove('hidden');
                    }
                };
                reader.readAsDataURL(file);
                
                // Clear the file input's value
                event.target.value = null;
            }

            /**
             * Clears the staged image for a specific panel.
             * @param {'a' | 'b'} panelSuffix - The panel to clear.
             */
            function clearStagedImage(panelSuffix) {
                if (panelSuffix === 'a') {
                    stagedImageA = null;
                    previewImgA.src = '';
                    chatImagePreviewA.classList.add('hidden');
                    chatFileInputA.value = null; // Clear file input
                } else {
                    stagedImageB = null;
                    previewImgB.src = '';
                    chatImagePreviewB.classList.add('hidden');
                    chatFileInputB.value = null; // Clear file input
                }
            }


            // --- Chat Session Management Functions ---

            /**
             * Loads all chats from localStorage and initializes the chat panels.
             */
            function loadChats() {
                const savedChats = localStorage.getItem(STORAGE_KEY_CHAT_SESSIONS);
                allChats = savedChats ? JSON.parse(savedChats) : {};
                
                activeChatIdA = localStorage.getItem(STORAGE_KEY_ACTIVE_CHAT_A);
                activeChatIdB = localStorage.getItem(STORAGE_KEY_ACTIVE_CHAT_B);

                if (Object.keys(allChats).length === 0) {
                    // Create two default chats if none exist
                    const newChatA = createNewChat(false); // don't save yet
                    const newChatB = createNewChat(false); // don't save yet
                    activeChatIdA = newChatA.id;
                    activeChatIdB = newChatB.id;
                    saveChats();
                }

                // Ensure active chat IDs are valid
                if (!allChats[activeChatIdA]) {
                    activeChatIdA = Object.keys(allChats)[0];
                    localStorage.setItem(STORAGE_KEY_ACTIVE_CHAT_A, activeChatIdA);
                }
                if (!allChats[activeChatIdB]) {
                    activeChatIdB = Object.keys(allChats)[0] || activeChatIdA; // Default to first or A's chat
                    localStorage.setItem(STORAGE_KEY_ACTIVE_CHAT_B, activeChatIdB);
                }

                renderChatListDropdowns();
                loadChatHistory('a', activeChatIdA);
                loadChatHistory('b', activeChatIdB);
            }

            /**
             * Saves all chat sessions and active IDs to localStorage.
             */
            function saveChats() {
                localStorage.setItem(STORAGE_KEY_CHAT_SESSIONS, JSON.stringify(allChats));
                localStorage.setItem(STORAGE_KEY_ACTIVE_CHAT_A, activeChatIdA);
                localStorage.setItem(STORAGE_KEY_ACTIVE_CHAT_B, activeChatIdB);
            }

            /**
             * Populates both chat session dropdowns with all available chats.
             */
            function renderChatListDropdowns() {
                const selects = [chatSelectA, chatSelectB];
                const sortedChatIds = Object.keys(allChats).sort((a, b) => (allChats[b].createdAt || 0) - (allChats[a].createdAt || 0));
                
                selects.forEach(select => {
                    select.innerHTML = ''; // Clear options
                    for (const chatId of sortedChatIds) {
                        const chat = allChats[chatId];
                        const option = document.createElement('option');
                        option.value = chatId;
                        // Use first user message as name, or a default
                        let chatName = chat.name;
                        if (!chatName && chat.messages.length > 0) {
                             const firstUserMsg = chat.messages.find(m => m.role === 'user');
                             if (firstUserMsg && firstUserMsg.content) {
                                chatName = `Chat: ${firstUserMsg.content.substring(0, 30)}...`;
                             }
                        }
                        if (!chatName) chatName = `Chat ${chatId.substring(0, 8)}`;
                        chat.name = chatName; // Save back to object
                        
                        option.textContent = chatName;
                        select.appendChild(option);
                    }
                });

                chatSelectA.value = activeChatIdA;
                chatSelectB.value = activeChatIdB;
            }

            /**
             * Loads and displays the messages for a given chat panel.
             * @param {'a' | 'b'} panelSuffix - The panel to load history for.
             * @param {string} chatId - The ID of the chat to load.
             */
            function loadChatHistory(panelSuffix, chatId) {
                const historyEl = (panelSuffix === 'a') ? chatHistoryA : chatHistoryB;
                const systemPromptEl = (panelSuffix === 'a') ? chatSystemPromptA : chatSystemPromptB;
                const modelSelectEl = (panelSuffix === 'a') ? chatModelSelectA : chatModelSelectB; // <-- NEW
                historyEl.innerHTML = '';
                const chat = allChats[chatId];

                if (!chat) {
                    console.error(`Chat not found: ${chatId}`);
                    const firstChatId = Object.keys(allChats)[0];
                    if (firstChatId) {
                        switchChat(panelSuffix, firstChatId);
                    }
                    return;
                }

                systemPromptEl.value = chat.systemPrompt || '';

                // <-- NEW: Load chat-specific model
                if (chat.model) {
                    modelSelectEl.value = chat.model;
                } else {
                    // Default to global model if chat has no model saved
                    modelSelectEl.value = modelSelect.value;
                    chat.model = modelSelectEl.value; // Save default back to chat
                }

                if (chat.messages.length > 0) {
                    chat.messages.forEach(msg => {
                        // NEW: Re-create dataUrl from saved base64 for display
                        let dataUrl = null;
                        if (msg.role === 'user' && msg.images && msg.images[0]) {
                            // Assume JPEG/PNG. This is a safe way to display base64 data.
                            dataUrl = `data:image/jpeg;base64,${msg.images[0]}`;
                        }
                        addMessageToChatUI(historyEl, msg.role, msg.content, dataUrl);
                    });
                } else {
                    addMessageToChatUI(historyEl, 'model', 'New chat. Say hello!', null);
                }
                historyEl.scrollTop = historyEl.scrollHeight;
            }

            /**
             * Creates a new chat session.
             * @param {boolean} doSave - Whether to save to localStorage immediately.
             * @returns {object} The new chat object.
             */
            function createNewChat(doSave = true) {
                const newChatId = crypto.randomUUID();
                const newChat = {
                    id: newChatId,
                    name: `New Chat ${new Date().toLocaleTimeString()}`,
                    messages: [],
                    createdAt: Date.now(),
                    systemPrompt: "",
                    model: modelSelect.value // <-- NEW: Default to global model
                };
                allChats[newChatId] = newChat;
                
                if (doSave) {
                    saveChats();
                    renderChatListDropdowns();
                }
                return newChat;
            }

            /**
             * Deletes a chat session by its ID.
             * @param {string} chatIdToDelete - The ID of the chat to delete.
             */
            function deleteChat(chatIdToDelete) {
                if (Object.keys(allChats).length <= 1) {
                    showMessage('Cannot delete the last chat session.', 'error');
                    return;
                }

                delete allChats[chatIdToDelete];
                
                const fallbackChatId = Object.keys(allChats)[0];

                if (activeChatIdA === chatIdToDelete) {
                    switchChat('a', fallbackChatId);
                }
                if (activeChatIdB === chatIdToDelete) {
                    switchChat('b', fallbackChatId);
                }

                saveChats();
                renderChatListDropdowns();
                showMessage('Chat session deleted.', 'success');
            }

            /**
             * Switches the active chat for a specific panel.
             * @param {'a' | 'b'} panelSuffix - The panel to switch.
             * @param {string} newChatId - The ID of the new chat.
             */
            function switchChat(panelSuffix, newChatId) {
                if (panelSuffix === 'a') {
                    activeChatIdA = newChatId;
                } else {
                    activeChatIdB = newChatId;
                }
                saveChats();
                loadChatHistory(panelSuffix, newChatId);
            }


            // --- Tab Logic ---
            const activeTabClasses = ['border-cyan-500', 'text-cyan-400'];
            const inactiveTabClasses = ['border-transparent', 'text-gray-400', 'hover:border-gray-500', 'hover:text-gray-300'];

            function switchTab(newTab, newPanel) {
                // Deactivate Chat
                tabChat.setAttribute('aria-selected', 'false');
                tabChat.classList.remove(...activeTabClasses);
                tabChat.classList.add(...inactiveTabClasses);
                panelChat.classList.add('hidden');

                // Deactivate Analysis
                tabAnalysis.setAttribute('aria-selected', 'false');
                tabAnalysis.classList.remove(...activeTabClasses);
                tabAnalysis.classList.add(...inactiveTabClasses);
                panelAnalysis.classList.add('hidden');

                // Activate New Tab/Panel
                newTab.setAttribute('aria-selected', 'true');
                newTab.classList.add(...activeTabClasses);
                newTab.classList.remove(...inactiveTabClasses);
                newPanel.classList.remove('hidden');
            }

            tabChat.addEventListener('click', (e) => { e.preventDefault(); switchTab(tabChat, panelChat); });
            tabAnalysis.addEventListener('click', (e) => { e.preventDefault(); switchTab(tabAnalysis, panelAnalysis); });


            /**
             * Generic function to call the Ollama API.
             */
            async function callOllama(apiPath, body, onStreamChunk, onStreamEnd) {
                const endpoint = ollamaEndpoint.value;
                if (!endpoint) {
                    showMessage('Ollama API endpoint is not set.', 'error');
                    return null;
                }
                if (!body.model) {
                    showMessage('No model selected. Check Configuration.', 'error');
                    return null;
                }

                const url = new URL(endpoint);
                url.pathname = apiPath;

                try {
                    const response = await fetch(url.toString(), {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(body),
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: `HTTP error! status: ${response.status}` }));
                        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                    }

                    // Handle STREAMING response
                    if (body.stream && response.body) {
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = '';
                        let fullResponse = '';

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop(); // Keep potential partial line

                            for (const line of lines) {
                                if (line.trim() === '') continue;
                                try {
                                    const chunk = JSON.parse(line);
                                    let contentChunk = '';
                                    if (apiPath === '/api/chat') contentChunk = chunk.message?.content || '';
                                    else contentChunk = chunk.response || '';

                                    if (contentChunk) {
                                        fullResponse += contentChunk;
                                        if (onStreamChunk) onStreamChunk(contentChunk);
                                    }
                                    if (chunk.done) {
                                        if (onStreamEnd) onStreamEnd(fullResponse);
                                        return null; // Stream finished
                                    }
                                } catch (e) {
                                    console.warn('Failed to parse stream line:', line, e);
                                }
                            }
                        }
                        if (onStreamEnd) onStreamEnd(fullResponse); // End of stream
                        return null;
                    }
                    
                    // Handle NON-STREAMING response
                    return await response.json();

                } catch (err) {
                    console.error('Ollama API call failed:', err);
                    let errorMessage = 'Failed to connect to Ollama. ';
                    if (err.message.includes('Failed to fetch')) {
                        errorMessage += 'Is the server running? Check CORS (OLLAMA_ORIGINS).';
                    } else {
                        errorMessage += err.message;
                    }
                    showMessage(errorMessage, 'error');
                    return null;
                }
            }


            // --- Event Listeners ---

            // 1. Analyze Button
            analyzeBtn.addEventListener('click', async () => {
                const prompt = analysisInput.value;
                if (!prompt) return;

                const model = modelSelect.value;
                const analysisSystemPrompt = 'You are an expert analyst. Analyze the following text and provide a concise summary of its key points, tone, and sentiment.';
                const userSystemPrompt = systemPrompt.value.trim();
                
                analysisOutput.value = 'Analyzing...';
                analysisOutput.classList.add('animate-pulse');
                analyzeBtn.disabled = true;
                analyzeBtn.textContent = 'Analyzing...';
                
                const payload = {
                    model: model,
                    prompt: `Text:\n"""\n${prompt}\n"""\n\nAnalysis:`,
                    system: userSystemPrompt || analysisSystemPrompt,
                    stream: false 
                };

                const data = await callOllama('/api/generate', payload);

                if (data && data.response) {
                    analysisOutput.value = data.response.trim();
                    showMessage(`Analysis complete with ${model}.`, 'success');
                } else {
                    analysisOutput.value = 'Error: Could not get analysis.';
                }
                
                analysisOutput.classList.remove('animate-pulse');
                analyzeBtn.disabled = false;
                analyzeBtn.textContent = 'Analyze Text';
            });

            // 2. Chat Send Handlers (for both panels)
            /**
             * Handles sending a chat message for a specific panel.
             * @param {'a' | 'b'} panelSuffix - The panel sending the message.
             */
            async function handleChatSend(panelSuffix) {
                const inputEl = (panelSuffix === 'a') ? chatInputA : chatInputB;
                const historyEl = (panelSuffix === 'a') ? chatHistoryA : chatHistoryB;
                const sendBtnEl = (panelSuffix === 'a') ? chatSendBtnA : chatSendBtnB;
                const activeChatId = (panelSuffix === 'a') ? activeChatIdA : activeChatIdB;
                const stagedImage = (panelSuffix === 'a') ? stagedImageA : stagedImageB;
                
                const message = inputEl.value.trim();
                if (!message && !stagedImage) return; // Don't send if empty

                const globalSystemPrompt = systemPrompt.value.trim();
                const chat = allChats[activeChatId];
                
                if (!chat) {
                    showMessage(`Error: No active chat found for panel ${panelSuffix}.`, 'error');
                    return;
                }

                const model = chat.model; // <-- NEW: Use chat-specific model
                const localSystemPrompt = chat.systemPrompt ? chat.systemPrompt.trim() : '';
                const finalSystemPrompt = localSystemPrompt || globalSystemPrompt;

                // Add user message to UI
                addMessageToChatUI(historyEl, 'user', message, stagedImage ? stagedImage.dataUrl : null);
                
                // Add user message to state (with API-ready base64)
                const userMessage = { role: 'user', content: message };
                if (stagedImage) {
                    userMessage.images = [stagedImage.base64];
                }
                chat.messages.push(userMessage);
                
                // Clear input and staged image
                inputEl.value = '';
                clearStagedImage(panelSuffix);

                // Add "typing" bubble
                const typingBubble = addMessageToChatUI(historyEl, 'model', '...');
                sendBtnEl.disabled = true;

                // Prepare messages for API call
                let messagesForApi = [...chat.messages];
                if (finalSystemPrompt) {
                    messagesForApi.unshift({ role: 'system', content: finalSystemPrompt });
                }

                const payload = {
                    model: model,
                    messages: messagesForApi,
                    stream: true
                };

                let fullResponse = '';
                const onStreamChunk = (chunk) => {
                    fullResponse += chunk;
                    typingBubble.textContent = fullResponse;
                    historyEl.scrollTop = historyEl.scrollHeight;
                };

                const onStreamEnd = (finalResponse) => {
                    typingBubble.classList.remove('animate-pulse');
                    typingBubble.textContent = finalResponse;
                    
                    // Add model response to state
                    chat.messages.push({ role: 'assistant', content: finalResponse });
                    
                    // Update chat name if it's the first user message
                    const userMessages = chat.messages.filter(m => m.role === 'user');
                    if (userMessages.length === 1 && userMessages[0].content) {
                        chat.name = `Chat: ${userMessages[0].content.substring(0, 30)}...`;
                        renderChatListDropdowns();
                    }
                    saveChats(); // Save updated messages and name
                    
                    sendBtnEl.disabled = false;
                    showMessage(`Chat response complete with ${model}.`, 'success');
                };
                
                await callOllama('/api/chat', payload, onStreamChunk, onStreamEnd);
            }

            // --- Panel A Listeners ---
            chatSendBtnA.addEventListener('click', () => handleChatSend('a'));
            chatInputA.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleChatSend('a');
                }
            });
            chatSystemPromptA.addEventListener('input', () => {
                if (allChats[activeChatIdA]) {
                    allChats[activeChatIdA].systemPrompt = chatSystemPromptA.value;
                    saveChats();
                }
            });
            // NEW: Model listener A
            chatModelSelectA.addEventListener('change', () => {
                if (allChats[activeChatIdA]) {
                    allChats[activeChatIdA].model = chatModelSelectA.value;
                    saveChats();
                    showMessage(`Panel A model set to ${chatModelSelectA.value}`, 'success');
                }
            });
            // NEW: Image listeners A
            chatAttachBtnA.addEventListener('click', () => chatFileInputA.click());
            chatFileInputA.addEventListener('change', (e) => handleImageUpload('a', e));
            removeImgBtnA.addEventListener('click', () => clearStagedImage('a'));


            // --- Panel B Listeners ---
            chatSendBtnB.addEventListener('click', () => handleChatSend('b'));
            chatInputB.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleChatSend('b');
                }
            });
            chatSystemPromptB.addEventListener('input', () => {
                if (allChats[activeChatIdB]) {
                    allChats[activeChatIdB].systemPrompt = chatSystemPromptB.value;
                    saveChats();
                }
            });
            // NEW: Model listener B
            chatModelSelectB.addEventListener('change', () => {
                if (allChats[activeChatIdB]) {
                    allChats[activeChatIdB].model = chatModelSelectB.value;
                    saveChats();
                    showMessage(`Panel B model set to ${chatModelSelectB.value}`, 'success');
                }
            });
            // NEW: Image listeners B
            chatAttachBtnB.addEventListener('click', () => chatFileInputB.click());
            chatFileInputB.addEventListener('change', (e) => handleImageUpload('b', e));
            removeImgBtnB.addEventListener('click', () => clearStagedImage('b'));


            // 3. Copy Buttons
            copyInputBtn.addEventListener('click', () => copyToClipboard(analysisInput.value, copyInputBtn));
            copyOutputBtn.addEventListener('click', () => copyToClipboard(analysisOutput.value, copyOutputBtn));

            // NEW: Test Connection Button
            testConnectionBtn.addEventListener('click', (e) => {
                e.preventDefault();
                showMessage('Testing connection...', 'success');
                checkConnectionAndLoadModels();
            });

            // 4. Local Storage Savers
            ollamaEndpoint.addEventListener('change', () => {
                localStorage.setItem(STORAGE_KEY_ENDPOINT, ollamaEndpoint.value);
                showMessage('Endpoint saved. Click "Test Connection" to apply.', 'success');
                // checkConnectionAndLoadModels(); // Removed - now manual
            });
            systemPrompt.addEventListener('input', () => localStorage.setItem(STORAGE_KEY_SYSTEM_PROMPT, systemPrompt.value));
            analysisInput.addEventListener('input', () => localStorage.setItem(STORAGE_KEY_ANALYSIS_INPUT, analysisInput.value));
            modelSelect.addEventListener('change', () => {
                const newModel = modelSelect.value;
                localStorage.setItem(STORAGE_KEY_MODEL, newModel);
                savedModel = newModel;
                showMessage(`Global default model saved: ${newModel}`, 'success');
            });

            // 5. NEW: Chat Session Listeners
            newChatBtn.addEventListener('click', () => {
                const newChat = createNewChat();
                // Make the new chat active in Panel A
                switchChat('a', newChat.id);
                renderChatListDropdowns(); // Re-render to show it
            });
            deleteChatBtnA.addEventListener('click', () => deleteChat(activeChatIdA));
            deleteChatBtnB.addEventListener('click', () => deleteChat(activeChatIdB));
            chatSelectA.addEventListener('change', (e) => switchChat('a', e.target.value));
            chatSelectB.addEventListener('change', (e) => switchChat('b', e.target.value));


            // --- Initial Check Function ---
            
            // NEW: Helper to populate a select element
            function populateModelSelect(selectElement, models) {
                const currentValue = selectElement.value; // Preserve current selection if possible
                selectElement.innerHTML = ''; // Clear
                
                if (models && models.length > 0) {
                    models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.name;
                        option.textContent = model.name;
                        selectElement.appendChild(option);
                    });

                    if (currentValue && models.some(m => m.name === currentValue)) {
                        selectElement.value = currentValue;
                    }
                } else {
                    selectElement.innerHTML = '<option value="" disabled>No models found</option>';
                }
            }

            async function checkConnectionAndLoadModels() {
                const endpoint = ollamaEndpoint.value;
                if (!endpoint) {
                    showMessage('Ollama API endpoint is not set.', 'error');
                    return;
                }
                
                const url = new URL(endpoint);
                url.pathname = '/api/tags';

                try {
                    const response = await fetch(url.toString());
                    if (response.ok) {
                        showMessage('Connected to Ollama. Fetching models...', 'success');
                        
                        const data = await response.json();
                        
                        // NEW: Populate all three model selects
                        populateModelSelect(modelSelect, data.models);
                        populateModelSelect(chatModelSelectA, data.models);
                        populateModelSelect(chatModelSelectB, data.models);

                        if (data.models && data.models.length > 0) {
                            if (savedModel && Array.from(modelSelect.options).some(opt => opt.value === savedModel)) {
                                modelSelect.value = savedModel;
                            } else {
                                modelSelect.selectedIndex = 0;
                                const newDefaultModel = modelSelect.value;
                                localStorage.setItem(STORAGE_KEY_MODEL, newDefaultModel);
                                savedModel = newDefaultModel;
                            }
                            showMessage('Connected and models loaded.', 'success');
                        } else {
                            modelSelect.innerHTML = '<option value="" disabled>No models found</option>'; // Keep this for the global one
                            showMessage('Connected, but no models found. Pull a model (e.g., `ollama pull llama3`).', 'error');
                        }
                    } else {
                        throw new Error(`Status ${response.status}`);
                    }
                } catch (err) {
                    showMessage('Failed to connect to Ollama. Check endpoint and CORS.', 'error');
                    // NEW: Clear all selects
                    const allSelects = [modelSelect, chatModelSelectA, chatModelSelectB];
                    allSelects.forEach(sel => sel.innerHTML = '<option value="" disabled>Connection failed</option>');
                }
            }

            // --- Run Initial Load ---
            loadChats(); // Load chats first to get active IDs
            checkConnectionAndLoadModels(); // Now check connection and load models
            
        });
    </script>
</body>
</html>