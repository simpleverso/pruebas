<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exam Grader & Sheet Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        button:focus-visible {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }
        /* Print-specific styles for the generator */
        @media print {
            body * {
                visibility: hidden;
            }
            .no-print {
                display: none !important;
            }
            #sheet-container, #sheet-container * {
                visibility: visible;
            }
            #sheet-container {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                margin: 0;
                padding: 1rem;
                border: none;
                box-shadow: none;
            }
             body {
                -webkit-print-color-adjust: exact;
                color-adjust: exact;
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-start py-8 px-4">

    <div class="w-full max-w-2xl mx-auto bg-white rounded-2xl shadow-lg p-6 md:p-8 m-4">
        
        <!-- Tab Navigation -->
        <div class="border-b border-gray-200 mb-6 no-print">
            <ul class="flex -mb-px" id="tab-nav">
                <li><a href="#grader" class="tab-link border-b-2 border-indigo-600 text-indigo-600 inline-block py-4 px-4 text-sm font-medium text-center">Grader</a></li>
                <li><a href="#generator" class="tab-link border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 inline-block py-4 px-4 text-sm font-medium text-center">Generator</a></li>
            </ul>
        </div>

        <!-- Grader Tab Content -->
        <div id="grader" class="tab-content">
            <div class="relative text-center mb-6">
                <h1 class="text-3xl font-bold text-gray-800">üìù OMR Exam Grader</h1>
                <p class="absolute top-0 right-0 text-xs font-mono text-gray-400">v5.3</p>
                <p class="text-gray-600 mt-2">Place a ‚ñ† marker at the top-left and a ‚ñ≤ at the bottom-right of the answer area.</p>
            </div>
            
            <div id="camera-container" class="relative w-full bg-gray-200 rounded-lg overflow-hidden border border-gray-300">
                <video id="video" class="absolute w-full h-full object-cover" style="opacity: 0; pointer-events: none;" playsinline autoplay muted></video>
                <canvas id="outputCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
            </div>

            <div class="mt-6 grid grid-cols-1 sm:grid-cols-2 gap-4">
                <button id="scanKeyBtn" class="w-full bg-blue-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-blue-700 transition-all duration-200 disabled:bg-gray-400" disabled>1. Scan Answer Key</button>
                <button id="gradeStudentBtn" class="w-full bg-green-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-green-700 transition-all duration-200 disabled:bg-gray-400" disabled>2. Grade Student Sheet</button>
            </div>

            <div id="scan-result" class="mt-4 text-center text-2xl font-bold text-blue-600 h-10"></div>
            <div id="status" class="mt-2 text-center text-gray-500 font-medium">Loading OpenCV... Press Start when ready.</div>
            <button id="startBtn" class="w-full mt-4 bg-gray-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-gray-800 transition-all duration-200">Start Camera</button>
        </div>
        
        <!-- Generator Tab Content -->
        <div id="generator" class="tab-content hidden">
            <div id="controls">
                <h1 class="text-2xl font-bold text-center text-gray-800 mb-2">Answer Sheet Generator</h1>
                <p class="text-center text-gray-500 mb-6">Create a custom, scanner-friendly answer sheet.</p>
                <div class="space-y-4">
                    <div class="relative">
                        <label for="question-count" class="absolute -top-2.5 left-2 inline-block bg-white px-1 text-xs font-medium text-gray-900">Number of Questions</label>
                        <input type="number" id="question-count" value="5" min="1" class="block w-full rounded-md border-0 py-3 px-4 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm">
                    </div>
                    <div class="flex flex-col sm:flex-row gap-4 items-center justify-center">
                        <button id="generate-btn" class="w-full sm:w-auto flex-1 bg-indigo-600 text-white font-semibold py-3 px-6 rounded-lg shadow-sm hover:bg-indigo-700">Generate Sheet</button>
                        <button id="print-btn" class="w-full sm:w-auto flex-1 bg-gray-700 text-white font-semibold py-3 px-6 rounded-lg shadow-sm hover:bg-gray-800" style="display: none;">Print Sheet</button>
                    </div>
                     <p class="text-xs text-center text-gray-500 mt-2">After generating, click the bubbles to create the answer key before printing.</p>
                </div>
            </div>
            <div id="sheet-container" class="w-full bg-white pt-8 mt-8">
                <div class="border-b-2 border-gray-400 pb-4 mb-6">
                    <div class="flex flex-col sm:flex-row justify-between gap-4">
                        <div class="flex-1"><strong class="text-gray-800">Name:</strong><div class="border-b border-gray-500 mt-2"></div></div>
                        <div class="flex-1"><strong class="text-gray-800">Class/Subject:</strong><div class="border-b border-gray-500 mt-2"></div></div>
                        <div class="flex-1 sm:flex-none"><strong class="text-gray-800">Date:</strong><div class="border-b border-gray-500 mt-2 w-full sm:w-32"></div></div>
                    </div>
                </div>
                <div id="sheet-content"><p class="text-center text-gray-500">Enter your settings and click "Generate Sheet" to begin.</p></div>
            </div>
        </div>
    </div>

    <script async src="https://docs.opencv.org/4.9.0/opencv.js" onload="onOpenCvReady();"></script>
    <script>
        // --- TAB SWITCHING LOGIC ---
        const tabNav = document.getElementById('tab-nav');
        const tabLinks = tabNav.querySelectorAll('.tab-link');
        const tabContents = document.querySelectorAll('.tab-content');

        tabNav.addEventListener('click', (e) => {
            e.preventDefault();
            const link = e.target.closest('a');
            if (!link) return;
            tabLinks.forEach(l => {
                l.classList.remove('border-indigo-600', 'text-indigo-600');
                l.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
            });
            link.classList.add('border-indigo-600', 'text-indigo-600');
            link.classList.remove('border-transparent', 'text-gray-500');
            tabContents.forEach(content => content.classList.add('hidden'));
            document.querySelector(link.getAttribute('href')).classList.remove('hidden');
        });

        // --- GRADER LOGIC ---
        const video = document.getElementById('video');
        const startBtn = document.getElementById('startBtn');
        const scanKeyBtn = document.getElementById('scanKeyBtn');
        const gradeStudentBtn = document.getElementById('gradeStudentBtn');
        const statusEl = document.getElementById('status');
        const scanResultEl = document.getElementById('scan-result');
        const outputCanvas = document.getElementById('outputCanvas');
        const cameraContainer = document.getElementById('camera-container');
        const ctx = outputCanvas.getContext('2d');

        let stream = null;
        let answerKey = null;
        let animationFrameId;

        function onOpenCvReady() {
            statusEl.textContent = 'OpenCV is ready.';
            startBtn.disabled = false;
        }

        startBtn.addEventListener('click', async () => {
            startBtn.disabled = true;
            statusEl.textContent = 'Starting camera...';
            try {
                if (stream) stream.getTracks().forEach(track => track.stop());
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } } });
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    const { videoWidth, videoHeight } = video;
                    outputCanvas.width = videoWidth;
                    outputCanvas.height = videoHeight;
                    
                    cameraContainer.style.aspectRatio = `${videoWidth} / ${videoHeight}`;

                    startBtn.textContent = 'Restart Camera';
                    scanKeyBtn.disabled = false;
                    gradeStudentBtn.disabled = true;
                    answerKey = null;
                    statusEl.textContent = 'Camera started. Looking for markers...';
                    scanResultEl.innerHTML = '';
                    processingLoop();
                };
                await video.play();

            } catch (err) {
                console.error("Error accessing camera: ", err);
                statusEl.textContent = 'Error: Could not access camera.';
            } finally {
                startBtn.disabled = false;
            }
        });
        
        scanKeyBtn.addEventListener('click', () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            const result = processImage(true); 
            if (result && result.answers && result.answers.length > 0) {
                answerKey = JSON.parse(JSON.stringify(result.answers));
                scanResultEl.textContent = `${result.answers.length} questions detected.`;
                statusEl.textContent = 'Answer key scanned. Ready to grade student sheets.';
                gradeStudentBtn.disabled = false;
            } else {
                 statusEl.textContent = 'Could not detect a valid answer key. Try again.';
                 scanResultEl.textContent = '';
            }
            if (result) {
                if (result.binaryImage) result.binaryImage.delete();
                if (result.transformMatrix) result.transformMatrix.delete();
            }
            processingLoop();
        });

        gradeStudentBtn.addEventListener('click', async () => {
            if (!answerKey) return;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            scanResultEl.textContent = '';

            const studentResult = processImage(true); 
            if (studentResult && studentResult.answers && studentResult.transformMatrix) {
                const studentAnswers = studentResult.answers;
                let score = 0;
                let missingAnswers = 0;
                
                const bmp = await createImageBitmap(studentResult.originalFrame);
                ctx.drawImage(bmp, 0, 0);
                
                const inverseM = new cv.Mat();
                cv.invert(studentResult.transformMatrix, inverseM);
                const scaleFactor = video.videoWidth / studentResult.warpedWidth;

                const numQuestions = Math.min(answerKey.length, studentAnswers.length);
                for (let i = 0; i < numQuestions; i++) {
                    const studentChoiceIndex = studentAnswers[i].choice;
                    const correctChoiceIndex = answerKey[i].choice;

                    if (studentChoiceIndex === -1) {
                        missingAnswers++;
                        const firstBubble = studentAnswers[i].group[0];
                        const lastBubble = studentAnswers[i].group[studentAnswers[i].group.length - 1];
                        let startVec = cv.matFromArray(1, 1, cv.CV_32FC2, [firstBubble.x, firstBubble.y]);
                        let endVec = cv.matFromArray(1, 1, cv.CV_32FC2, [lastBubble.x, lastBubble.y]);
                        let startDstVec = new cv.Mat(1, 1, cv.CV_32FC2);
                        let endDstVec = new cv.Mat(1, 1, cv.CV_32FC2);
                        cv.perspectiveTransform(startVec, startDstVec, inverseM);
                        cv.perspectiveTransform(endVec, endDstVec, inverseM);
                        const startPoint = { x: startDstVec.data32F[0], y: startDstVec.data32F[1] };
                        const endPoint = { x: endDstVec.data32F[0], y: endDstVec.data32F[1] };
                        drawLine(ctx, startPoint, endPoint, 'rgba(255, 165, 0, 0.8)');
                        startVec.delete(); endVec.delete(); startDstVec.delete(); endDstVec.delete();
                    } else {
                        if (studentChoiceIndex === correctChoiceIndex) score++;
                        for (let j = 0; j < studentAnswers[i].group.length; j++) {
                            const circle = studentAnswers[i].group[j];
                            let srcVec = cv.matFromArray(1, 1, cv.CV_32FC2, [circle.x, circle.y]);
                            let dstVec = new cv.Mat(1, 1, cv.CV_32FC2);
                            cv.perspectiveTransform(srcVec, dstVec, inverseM);
                            const originalCircle = { x: dstVec.data32F[0], y: dstVec.data32F[1], radius: circle.radius * scaleFactor };
                            srcVec.delete(); dstVec.delete();
                            if (j === correctChoiceIndex) drawCircle(ctx, originalCircle, 'rgba(0, 255, 0, 0.7)');
                            if (j === studentChoiceIndex && studentChoiceIndex !== correctChoiceIndex) drawCircle(ctx, originalCircle, 'rgba(255, 0, 0, 0.7)');
                        }
                    }
                }
                statusEl.textContent = 'Grading complete. Press "Restart Camera" to continue.';
                let resultText = `Score: ${score} / ${answerKey.length}`;
                if (missingAnswers > 0) resultText += ` and ${missingAnswers} missing response${missingAnswers > 1 ? 's' : ''}`;
                scanResultEl.textContent = resultText;
                
                inverseM.delete();
                studentResult.binaryImage.delete();
                studentResult.transformMatrix.delete();
            } else {
                 statusEl.textContent = 'Could not read student sheet. Please try again.';
                 if (studentResult) {
                    if (studentResult.binaryImage) studentResult.binaryImage.delete();
                    if (studentResult.transformMatrix) studentResult.transformMatrix.delete();
                 }
                 processingLoop(); // Restart if grading failed
            }
        });
        
        function processingLoop() {
            if (!video.srcObject || video.paused || video.ended) return;
            const result = processImage(false);
            if (result && result.binaryImage) {
                cv.imshow('outputCanvas', result.binaryImage);
                result.binaryImage.delete();
                if (result.transformMatrix) result.transformMatrix.delete();
            }
            animationFrameId = requestAnimationFrame(processingLoop);
        }

        function drawCircle(context, circle, color) {
            context.beginPath();
            context.arc(circle.x, circle.y, circle.radius + 6, 0, 2 * Math.PI, false);
            context.lineWidth = 4;
            context.strokeStyle = color;
            context.stroke();
        }
        
        function drawLine(context, start, end, color) {
            context.beginPath();
            context.moveTo(start.x, start.y);
            context.lineTo(end.x, end.y);
            context.lineWidth = 5;
            context.strokeStyle = color;
            context.stroke();
        }

        function processImage(isFinalScan) {
            if (!window.cv || video.readyState < 3) return null;
            const mats = [];
            let src, gray, binary, warpedGray, cleanBinary, M, originalFrame;
            try {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = video.videoWidth; tempCanvas.height = video.videoHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
                if (isFinalScan) originalFrame = tempCanvas; // **FIX: Pass canvas reference**
                src = cv.matFromImageData(tempCtx.getImageData(0, 0, video.videoWidth, video.videoHeight));
                mats.push(src);
                gray = new cv.Mat(); mats.push(gray);
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                binary = new cv.Mat(); mats.push(binary);
                cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 5);
                let kernel = cv.Mat.ones(3, 3, cv.CV_8U); mats.push(kernel);
                cv.morphologyEx(binary, binary, cv.MORPH_OPEN, kernel);
                let contours = new cv.MatVector(); mats.push(contours);
                let hierarchy = new cv.Mat(); mats.push(hierarchy);
                cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                let square, triangle;
                for (let i = 0; i < contours.size(); ++i) {
                    let cnt = contours.get(i);
                    let perimeter = cv.arcLength(cnt, true);
                    let approx = new cv.Mat();
                    cv.approxPolyDP(cnt, approx, 0.04 * perimeter, true);
                    let area = cv.contourArea(cnt);
                    if (approx.rows === 4 && area > 1500) square = cv.boundingRect(cnt);
                    else if (approx.rows === 3 && area > 1500) triangle = cv.boundingRect(cnt);
                    approx.delete();
                    cnt.delete();
                }
                if (!square || !triangle) {
                    if (isFinalScan) statusEl.textContent = 'Markers not found.';
                    return { answers: [], binaryImage: binary.clone(), transformMatrix: null, originalFrame: isFinalScan ? originalFrame : null };
                }
                if(!isFinalScan) statusEl.textContent = 'Markers found! Ready to scan.';
                const [tl, tr, bl, br] = [new cv.Point(square.x, square.y), new cv.Point(triangle.x + triangle.width, square.y), new cv.Point(square.x, triangle.y + triangle.height), new cv.Point(triangle.x + triangle.width, triangle.y + triangle.height)];
                const width = Math.max(br.x - tl.x, bl.x - tr.x);
                const height = Math.max(br.y - tr.y, bl.y - tl.y);
                const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y]);
                const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, width, 0, width, height, 0, height]);
                mats.push(srcTri); mats.push(dstTri);
                M = cv.getPerspectiveTransform(srcTri, dstTri);
                warpedGray = new cv.Mat(); mats.push(warpedGray);
                cv.warpPerspective(gray, warpedGray, M, new cv.Size(width, height));
                let warpedBinary = new cv.Mat(); mats.push(warpedBinary);
                cv.adaptiveThreshold(warpedGray, warpedBinary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 5);
                let contoursWarped = new cv.MatVector(); mats.push(contoursWarped);
                let hierarchyWarped = new cv.Mat(); mats.push(hierarchyWarped);
                cv.findContours(warpedBinary, contoursWarped, hierarchyWarped, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                let circles = [];
                let validContours = new cv.MatVector();
                for (let i = 0; i < contoursWarped.size(); ++i) {
                     let cnt = contoursWarped.get(i);
                     let area = cv.contourArea(cnt);
                     if (area < 50 || area > 2000) { cnt.delete(); continue; }
                     let perimeter = cv.arcLength(cnt, true);
                     let circularity = (4 * Math.PI * area) / (perimeter * perimeter);
                     if (circularity > 0.6) {
                         let circle = cv.minEnclosingCircle(cnt);
                         circles.push({ x: circle.center.x, y: circle.center.y, radius: circle.radius });
                         validContours.push_back(cnt);
                     }
                     cnt.delete();
                }
                cleanBinary = cv.Mat.zeros(warpedGray.rows, warpedGray.cols, cv.CV_8UC1);
                cv.drawContours(cleanBinary, validContours, -1, new cv.Scalar(255), cv.FILLED);
                validContours.delete();
                if (circles.length === 0) return { answers: [], binaryImage: cleanBinary, transformMatrix: M.clone(), warpedWidth: width, originalFrame: isFinalScan ? originalFrame : null };
                circles.sort((a, b) => (Math.abs(a.y - b.y) > 20) ? a.y - b.y : a.x - b.x);
                const questions = [];
                let currentQuestion = [circles[0]];
                for (let i = 1; i < circles.length; i++) {
                    if (Math.abs(circles[i].y - currentQuestion[0].y) < 20) currentQuestion.push(circles[i]);
                    else { questions.push(currentQuestion); currentQuestion = [circles[i]]; }
                }
                questions.push(currentQuestion);
                const answers = [];
                for (const group of questions) {
                    let darkestCircleIndex = -1, minIntensity = 255;
                    for (let i = 0; i < group.length; i++) {
                        const circle = group[i];
                        const rect = new cv.Rect(Math.max(0, circle.x - circle.radius), Math.max(0, circle.y - circle.radius), circle.radius * 2, circle.radius * 2);
                        if (rect.x + rect.width > warpedGray.cols || rect.y + rect.height > warpedGray.rows) continue;
                        let roi = warpedGray.roi(rect);
                        let mean = cv.mean(roi)[0];
                        if (mean < minIntensity) { minIntensity = mean; darkestCircleIndex = i; }
                        roi.delete();
                    }
                    answers.push({ group, choice: minIntensity < 145 ? darkestCircleIndex : -1 });
                }
                return { answers, binaryImage: cleanBinary, transformMatrix: M.clone(), warpedWidth: width, originalFrame: isFinalScan ? originalFrame : null };
            } catch (error) {
                console.error("Error during image processing:", error);
                if(cleanBinary && !cleanBinary.isDeleted()) cleanBinary.delete();
                return null;
            } finally {
                if (M && !M.isDeleted()) M.delete();
                mats.forEach(mat => { if(mat && !mat.isDeleted()) mat.delete();});
            }
        }
        
        window.addEventListener('beforeunload', () => {
            if (stream) stream.getTracks().forEach(track => track.stop());
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
        });

        // --- GENERATOR LOGIC ---
        const generateBtn = document.getElementById('generate-btn');
        const printBtn = document.getElementById('print-btn');
        const questionCountInput = document.getElementById('question-count');
        const sheetContent = document.getElementById('sheet-content');

        const generateSheet = () => {
            const count = parseInt(questionCountInput.value, 10);
            if (isNaN(count) || count < 1) {
                sheetContent.innerHTML = `<p class="text-center text-red-500">Please enter a valid number of questions.</p>`;
                printBtn.style.display = 'none';
                return;
            }
            sheetContent.innerHTML = '';
            
            const mainContainer = document.createElement('div');
            mainContainer.className = "flex justify-center";

            const gridWrapper = document.createElement('div');
            mainContainer.appendChild(gridWrapper);

            const createRow = () => {
                const row = document.createElement('div');
                row.className = 'flex items-stretch'; 
                const numberCol = document.createElement('div');
                numberCol.className = 'w-12 text-right font-bold flex items-center justify-end pr-4';
                const optionsCol = document.createElement('div');
                optionsCol.className = 'flex items-center space-x-10';
                row.appendChild(numberCol);
                row.appendChild(optionsCol);
                return { row, numberCol, optionsCol };
            };
            
            const header = createRow();
            header.numberCol.innerHTML = `&nbsp;`;
            ['A', 'B', 'C'].forEach(letter => {
                const wrapper = document.createElement('div');
                wrapper.className = 'w-12 h-8 flex justify-center items-center font-semibold text-gray-800';
                wrapper.textContent = letter;
                header.optionsCol.appendChild(wrapper);
            });
            gridWrapper.appendChild(header.row);

            const topMarker = createRow();
            topMarker.numberCol.innerHTML = `&nbsp;`;
            const squareWrapper = document.createElement('div');
            squareWrapper.className = 'w-12 h-8 flex justify-center items-center';
            squareWrapper.innerHTML = `<div class="w-8 h-8 bg-black"></div>`;
            topMarker.optionsCol.appendChild(squareWrapper);
            topMarker.optionsCol.appendChild(document.createElement('div')).className = 'w-12';
            topMarker.optionsCol.appendChild(document.createElement('div')).className = 'w-12';
            gridWrapper.appendChild(topMarker.row);

            for (let i = 1; i <= count; i++) {
                const item = createRow();
                item.numberCol.textContent = `${i}.`;
                ['A', 'B', 'C'].forEach(() => {
                    const optionWrapper = document.createElement('div');
                    optionWrapper.className = 'w-12 py-2 flex justify-center items-center cursor-pointer';
                    const circle = document.createElement('div');
                    circle.className = 'w-6 h-6 border-2 border-gray-500 rounded-full';
                    optionWrapper.appendChild(circle);
                    item.optionsCol.appendChild(optionWrapper);
                    optionWrapper.addEventListener('click', () => {
                        const isSelected = circle.classList.contains('bg-black');
                        item.optionsCol.querySelectorAll('div.rounded-full').forEach(c => c.classList.remove('bg-black'));
                        if (!isSelected) circle.classList.add('bg-black');
                    });
                });
                gridWrapper.appendChild(item.row);
             }

            const bottomMarker = createRow();
            bottomMarker.numberCol.innerHTML = `&nbsp;`;
            bottomMarker.optionsCol.appendChild(document.createElement('div')).className = 'w-12';
            bottomMarker.optionsCol.appendChild(document.createElement('div')).className = 'w-12';
            const triangleWrapper = document.createElement('div');
            triangleWrapper.className = 'w-12 h-8 flex justify-center items-center';
            triangleWrapper.innerHTML = `<svg width="32" height="32" viewBox="0 0 100 100"><polygon points="50,0 100,100 0,100" fill="black"></polygon></svg>`;
            bottomMarker.optionsCol.appendChild(triangleWrapper);
            gridWrapper.appendChild(bottomMarker.row);
            
            sheetContent.appendChild(mainContainer);
            printBtn.style.display = 'inline-block';
        };

        const printSheet = () => { window.print(); };
        generateBtn.addEventListener('click', generateSheet);
        printBtn.addEventListener('click', printSheet);
        generateSheet(); // Also generate on initial load
    </script>
</body>
</html>

